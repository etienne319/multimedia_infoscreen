#!/usr/bin/python3 -u
# -*- coding: utf-8 -*-

"""
multimedia: play/change/stop sport stream on button event

 Copyright (C) 2018 Hendrik Hagendorn

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import json
import os
import signal
import socket
import sys
import time
from modules import registry, utils
from modules import *
from RPi import GPIO


PIN = 16

class Dispatcher():
    SOCKET_ADDR = '/tmp/selector.ctrl'

    def __init__(self):
        self.selection_id = None
        self.module = None
        self.ignore_callback = False

    def init(self):
        signal.signal(signal.SIGTERM, self.sigterm_handler)
        signal.signal(signal.SIGINT, self.sigterm_handler)
        signal.signal(signal.SIGUSR1, self.sigusr1_handler)
        signal.signal(signal.SIGUSR2, self.sigusr2_handler)

        GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
        GPIO.add_event_detect(PIN, GPIO.RISING, callback=self.button_callback, bouncetime=200)

        for meta in registry.get_all_metadata():
            utils.download_file(meta['picon'], meta['picon_url'])

        for module in registry.get_all_modules():
            module.refresh()

    def run(self):
        try:
            os.unlink(self.SOCKET_ADDR)
        except OSError:
            if os.path.exists(self.SOCKET_ADDR):
                raise

        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(self.SOCKET_ADDR)
        os.chmod(self.SOCKET_ADDR, 0o666)
        sock.listen(1)

        while True:
            connection, client_address = sock.accept()
            try:
                cmd = connection.recv(38).decode("utf-8")
                if cmd == 'get modules':
                    modules = self.get_modules()
                    connection.sendall(json.dumps(modules).encode())
                elif cmd.startswith('get entries '):
                    entries = self.get_module_entries(cmd[4:])
                    connection.sendall(json.dumps(entries).encode())
                elif cmd == 'get entries':
                    entries = self.module.get_entries()
                    connection.sendall(json.dumps(entries).encode())
                elif cmd == 'up':
                    self.up()
                elif cmd == 'down':
                    self.down()
                elif cmd == 'select':
                    self.select()
                elif cmd.startswith('select module '):
                    selection_id = self.get_module_index(cmd[14:])
                    if selection_id != None:
                        self.module = None
                        self.selection_id = selection_id
                        self.select()
                elif cmd.startswith('select entry '):
                    self.selection_id = int(cmd[13:])
                    utils.ib_update_selection(self.selection_id)
                    self.select()
                elif cmd == 'exit':
                    self.exit()
            finally:
                connection.close()

    def reset(self):
        self.selection_id = None
        self.module = None

    def initialize_module(self):
        if registry.get_length() == 1:
            self.module = registry.get_all_modules()[0]
            self.module.handle_short_press()
        else:
            self.selection_id = 0
            utils.ib_update_selection(self.selection_id)
            utils.ib_update_selector(registry.get_all_metadata())
            utils.ib_notify('infoscreen/selector/visible', 'true')

    def get_modules(self):
        modules = []

        for metadata in registry.get_all_metadata():
            modules.append({
                'title': metadata['title'],
                'id': metadata['id']
            })

        return modules

    def get_module_index(self, module_id):
        for idx, metadata in enumerate(registry.get_all_metadata()):
            if metadata['id'] == module_id:
                return idx

        return None

    def get_module_entries(self, module_id):
        module = None

        for idx, metadata in enumerate(registry.get_all_metadata()):
            if metadata['id'] == module_id:
                module = registry.get_all_modules()[idx]

        return module.get_entries()

    def up(self):
        print('up.')

        if self.module:
            self.module.up()
        elif self.selection_id == None:
            self.initialize_module()
        else:
            self.selection_id = (self.selection_id - 1) % registry.get_length()
            utils.ib_update_selection(self.selection_id)

    def down(self):
        print('down.')

        if self.module:
            self.module.down()
        elif self.selection_id == None:
            self.initialize_module()
        else:
            self.selection_id = (self.selection_id + 1) % registry.get_length()
            utils.ib_update_selection(self.selection_id)

    def select(self):
        print('select.')

        if self.module:
            self.module.select()
        elif self.selection_id != None:
            self.module = registry.get_all_modules()[self.selection_id]
            self.selection_id = None
            self.module.init()

    def exit(self):
        print('exit.')

        if self.module:
            self.module.exit()

    def short_press(self):
        print('short press.')

        self.down()

    def long_press(self):
        print('long press.')

        self.select()

    def button_callback(self, channel):
        if self.ignore_callback:
            print('ignore callback')
            return

        time.sleep(0.005)
        if GPIO.input(channel) == GPIO.LOW:
            print('level less than 5 ms')
            return

        if not registry.ready():
            print('modules not ready')
            return

        print('button pressed.')
        time.sleep(0.2)
        if GPIO.input(channel) == GPIO.LOW:
            self.short_press()
        else:
            time.sleep(0.2)
            if GPIO.input(channel) == GPIO.LOW:
                self.short_press()
            else:
                self.ignore_callback = True # removing and readding the callback segfaults every now and then
                time.sleep(0.35)
                if GPIO.input(channel) == GPIO.HIGH:
                    self.long_press()
                    time.sleep(1)
                self.ignore_callback = False

    def sigterm_handler(self, signal, frame):
        if self.module:
            self.module.terminate()

        GPIO.cleanup()
        print('bye.')
        sys.exit(0)

    def sigusr1_handler(self, signal, frame):
        print("usr1")

        if self.module:
            self.module.terminate()

    def sigusr2_handler(self, signal, frame):
        print("usr2")
        for module in registry.get_all_modules():
            module.reload_epg()

if __name__ == '__main__':
    dispatcher = Dispatcher()
    registry.register_dispatcher(dispatcher)
    dispatcher.init()
    dispatcher.run()
